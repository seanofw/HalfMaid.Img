using System.Drawing;
using System.Drawing.Imaging;

#pragma warning disable CA1416

namespace HalfMaid.Img.Gdi
{
	public static class ImageBitmapExtensions
	{
		/// <summary>
		/// Convert the given image to a Windows Bitmap object, in Windows 32-bit BGRA format
		/// or in 24-bit BGR format.
		/// </summary>
		/// <param name="image">The image to convert to a Windows Bitmap.</param>
		/// <param name="includeAlpha">Whether to create a 32-bit image that includes alpha,
		/// or a 24-bit image that excludes alpha.</param>
		/// <returns>A copy of the image as a Windows Bitmap.  The caller is responsible
		/// for eventually Dispose()ing of the Bitmap that is returned by this.</returns>
		/// <remarks>
		/// This is heavily optimized to be about as good as the operation can
		/// be, and not just for C#.  The loops are unrolled, and reads and writes are
		/// rearranged to avoid pipeline stalls.  The resulting assembly is very nearly
		/// the same instructions generated by clang for the equivalent C code.
		/// </remarks>
		public static Bitmap ToBitmap(this Image32 image, bool includeAlpha = true)
			=> ToBitmap((PureImage32)image, includeAlpha);

		/// <summary>
		/// Convert the given image to a Windows Bitmap object, in Windows 32-bit BGRA format
		/// or in 24-bit BGR format.
		/// </summary>
		/// <param name="image">The image to convert to a Windows Bitmap.</param>
		/// <param name="includeAlpha">Whether to create a 32-bit image that includes alpha,
		/// or a 24-bit image that excludes alpha.</param>
		/// <returns>A copy of the image as a Windows Bitmap.  The caller is responsible
		/// for eventually Dispose()ing of the Bitmap that is returned by this.</returns>
		/// <remarks>
		/// This is heavily optimized to be about as good as the operation can
		/// be, and not just for C#.  The loops are unrolled, and reads and writes are
		/// rearranged to avoid pipeline stalls.  The resulting assembly is very nearly
		/// the same instructions generated by clang for the equivalent C code.
		/// </remarks>
		public static Bitmap ToBitmap(this PureImage32 image, bool includeAlpha = true)
		{
			int width = image.Width;
			int height = image.Height;
			if (width <= 0 || height <= 0)
				return new Bitmap(1, 1,
					includeAlpha ? PixelFormat.Format32bppArgb : PixelFormat.Format24bppRgb);

			Bitmap bitmap = new Bitmap(width, height,
				includeAlpha ? PixelFormat.Format32bppArgb : PixelFormat.Format24bppRgb);

			BitmapData bitmapData = bitmap.LockBits(new Rectangle(0, 0, width, height),
				ImageLockMode.ReadOnly, bitmap.PixelFormat);

			try
			{
				unsafe
				{
					fixed (Color32* srcBase = image.Data)
					{
						Color32* src = srcBase;
						byte* destRow = (byte*)bitmapData.Scan0;

						if (includeAlpha)
						{
							// 32-bit BGRA format.
							for (int y = 0; y < height; y++)
							{
								byte* dest = destRow;
								int count = width;

								while (count >= 4)
								{
									byte b = src[0].B;
									byte g = src[0].G;
									byte r = src[0].R;
									byte a = src[0].A;
									dest[0] = b;
									dest[1] = g;
									dest[2] = r;
									dest[3] = a;

									b = src[1].B;
									g = src[1].G;
									r = src[1].R;
									a = src[1].A;
									dest[4] = b;
									dest[5] = g;
									dest[6] = r;
									dest[7] = a;

									b = src[2].B;
									g = src[2].G;
									r = src[2].R;
									a = src[2].A;
									dest[8] = b;
									dest[9] = g;
									dest[10] = r;
									dest[11] = a;

									b = src[3].B;
									g = src[3].G;
									r = src[3].R;
									a = src[3].A;
									dest[12] = b;
									dest[13] = g;
									dest[14] = r;
									dest[15] = a;

									src += 4;
									dest += 16;
									count -= 4;
								}
								if ((count & 2) != 0)
								{
									byte b = src[0].B;
									byte g = src[0].G;
									byte r = src[0].R;
									byte a = src[0].A;
									dest[0] = b;
									dest[1] = g;
									dest[2] = r;
									dest[3] = a;

									b = src[1].B;
									g = src[1].G;
									r = src[1].R;
									a = src[1].A;
									dest[4] = b;
									dest[5] = g;
									dest[6] = r;
									dest[7] = a;

									src += 2;
									dest += 8;
								}
								if ((count & 1) != 0)
								{
									byte b = src[0].B;
									byte g = src[0].G;
									byte r = src[0].R;
									byte a = src[0].A;
									dest[0] = b;
									dest[1] = g;
									dest[2] = r;
									dest[3] = a;
									src++;
								}

								destRow += bitmapData.Stride;
							}
						}
						else
						{
							// 24-bit BGR format.
							for (int y = 0; y < height; y++)
							{
								byte* dest = destRow;
								int count = width;

								while (count >= 4)
								{
									byte b = src[0].B;
									byte g = src[0].G;
									byte r = src[0].R;
									dest[0] = b;
									dest[1] = g;
									dest[2] = r;

									b = src[1].B;
									g = src[1].G;
									r = src[1].R;
									dest[3] = b;
									dest[4] = g;
									dest[5] = r;

									b = src[2].B;
									g = src[2].G;
									r = src[2].R;
									dest[6] = b;
									dest[7] = g;
									dest[8] = r;

									b = src[3].B;
									g = src[3].G;
									r = src[3].R;
									dest[9] = b;
									dest[10] = g;
									dest[11] = r;

									src += 4;
									dest += 12;
									count -= 4;
								}
								if ((count & 2) != 0)
								{
									byte b = src[0].B;
									byte g = src[0].G;
									byte r = src[0].R;
									dest[0] = b;
									dest[1] = g;
									dest[2] = r;

									b = src[1].B;
									g = src[1].G;
									r = src[1].R;
									dest[3] = b;
									dest[4] = g;
									dest[5] = r;

									src += 2;
									dest += 6;
								}
								if ((count & 1) != 0)
								{
									byte b = src[0].B;
									byte g = src[0].G;
									byte r = src[0].R;
									dest[0] = b;
									dest[1] = g;
									dest[2] = r;
									src++;
								}

								destRow += bitmapData.Stride;
							}
						}
					}
				}
			}
			finally
			{
				bitmap.UnlockBits(bitmapData);
			}

			return bitmap;
		}

		/// <summary>
		/// Convert a Windows Bitmap to an Image8.
		/// </summary>
		/// <param name="bitmap">The Windows Bitmap to convert to an Image8.</param>
		/// <returns>A copy of the Windows Bitmap's data as an 8-bit paletted Image8, or
		/// null if the source data had more than 8 bits per pixel.</returns>
		public static Image8? ToImage8(this Bitmap bitmap)
			=> bitmap.PixelFormat == PixelFormat.Format1bppIndexed
					|| bitmap.PixelFormat == PixelFormat.Format4bppIndexed
					|| bitmap.PixelFormat == PixelFormat.Format8bppIndexed
				? (Image8)ToIImage(bitmap)
				: null;

		/// <summary>
		/// Convert a Windows Bitmap to an Image.
		/// </summary>
		/// <param name="bitmap">The Windows Bitmap to convert to an Image.</param>
		/// <returns>A copy of the Windows Bitmap's data as a 32-bit RGBA Image.</returns>
		public static Image32 ToImage32(this Bitmap bitmap)
			=> ToIImage(bitmap).ToImage32();

		/// <summary>
		/// Convert a Windows Bitmap to an IImage, whichever image format is the
		/// closest match for the given Bitmap.
		/// </summary>
		/// <param name="bitmap">The Windows Bitmap to convert to an IImage.</param>
		/// <returns>A copy of the Windows Bitmap's data as an IImage.</returns>
		/// <exception cref="NotSupportedException">Thrown if the bitmap pixel format is
		/// a rare, unsupported format (mostly 16-bit formats or 48-bit/64-bit formats).</exception>
		public static IImage ToIImage(this Bitmap bitmap)
		{
			if (bitmap == null)
				throw new ArgumentNullException(nameof(bitmap));

			BitmapData bitmapData = bitmap.LockBits(
				new Rectangle(0, 0, bitmap.Width, bitmap.Height),
				ImageLockMode.ReadOnly, bitmap.PixelFormat);
			try
			{
				unsafe
				{
					switch (bitmap.PixelFormat)
					{
						case PixelFormat.Format1bppIndexed:
							Image8 image8 = new Image8(bitmap.Width, bitmap.Height,
								DecodePalette(bitmap.Palette.Entries).AsSpan());
							DecodeBitmap1Bit(bitmapData, image8);
							return image8;

						case PixelFormat.Format4bppIndexed:
							image8 = new Image8(bitmap.Width, bitmap.Height,
								DecodePalette(bitmap.Palette.Entries).AsSpan());
							DecodeBitmap4Bit(bitmapData, image8);
							return image8;

						case PixelFormat.Format8bppIndexed:
							image8 = new Image8(bitmap.Width, bitmap.Height,
								DecodePalette(bitmap.Palette.Entries).AsSpan());
							DecodeBitmap8Bit(bitmapData, image8);
							return image8;

						case PixelFormat.Format24bppRgb:
							Image32 image = new Image32(bitmap.Width, bitmap.Height);
							DecodeBitmap24Bit(bitmapData, image, 3);
							return image;

						case PixelFormat.Format32bppRgb:
							image = new Image32(bitmap.Width, bitmap.Height);
							DecodeBitmap24Bit(bitmapData, image, 4);
							return image;

						case PixelFormat.Format32bppArgb:
						case PixelFormat.Format32bppPArgb:
							image = new Image32(bitmap.Width, bitmap.Height);
							DecodeBitmap32Bit(bitmapData, image);
							return image;

						default:
							throw new NotSupportedException($"Pixel format '{bitmap.PixelFormat}' is not supported.");
					}
				}
			}
			finally
			{
				bitmap.UnlockBits(bitmapData);
			}
		}

		private static unsafe void DecodeBitmap1Bit(BitmapData bitmapData, Image8 image)
		{
			fixed (byte* destStart = image.Data)
			{
				byte* dest = destStart;
				byte* srcStart = (byte*)bitmapData.Scan0;
				for (int y = 0; y < image.Height; y++)
				{
					for (int x = 0; x < image.Width; x++)
					{
						int bit = (srcStart[x >> 3] >> (x & 7)) & 1;
						*dest++ = (byte)bit;
					}
					srcStart += bitmapData.Stride;
				}
			}
		}

		private static unsafe void DecodeBitmap4Bit(BitmapData bitmapData, Image8 image)
		{
			fixed (byte* destStart = image.Data)
			{
				byte* dest = destStart;
				byte* srcStart = (byte*)bitmapData.Scan0;
				for (int y = 0; y < image.Height; y++)
				{
					int pairs = image.Width >> 1;
					int x;
					for (x = 0; x < pairs; x++)
					{
						byte src = srcStart[x];
						dest[0] = (byte)(src >> 4);
						dest[1] = (byte)(src & 0xF);
						dest += 2;
					}
					if ((image.Width & 1) != 0)
						*dest++ = (byte)(srcStart[x] >> 4);
					srcStart += bitmapData.Stride;
				}
			}
		}

		private static unsafe void DecodeBitmap8Bit(BitmapData bitmapData, Image8 image)
		{
			fixed (byte* destStart = image.Data)
			{
				byte* dest = destStart;
				byte* srcStart = (byte*)bitmapData.Scan0;
				for (int y = 0; y < image.Height; y++)
				{
					byte* src = srcStart;
					byte* end = src + image.Width;

					while (src < end)
						*dest++ = *src++;

					srcStart += bitmapData.Stride;
				}
			}
		}

		private static unsafe void DecodeBitmap24Bit(BitmapData bitmapData, Image32 image, int colorStep)
		{
			fixed (Color32* destStart = image.Data)
			{
				Color32* dest = destStart;
				byte* srcStart = (byte*)bitmapData.Scan0;
				for (int y = 0; y < image.Height; y++)
				{
					byte* src = srcStart;
					byte* end = src + image.Width * colorStep;

					while (src < end)
					{
						*dest++ = new Color32(src[2], src[1], src[0]);
						src += colorStep;
					}

					srcStart += bitmapData.Stride;
				}
			}
		}

		private static unsafe void DecodeBitmap32Bit(BitmapData bitmapData, Image32 image)
		{
			fixed (Color32* destStart = image.Data)
			{
				Color32* dest = destStart;
				byte* srcStart = (byte*)bitmapData.Scan0;
				for (int y = 0; y < image.Height; y++)
				{
					byte* src = srcStart;
					byte* end = src + image.Width * 4;

					while (src < end)
					{
						*dest++ = new Color32(src[2], src[1], src[0], src[3]);
						src += 4;
					}

					srcStart += bitmapData.Stride;
				}
			}
		}

		private static Color32[] DecodePalette(System.Drawing.Color[] entries)
		{
			Color32[] result = new Color32[entries.Length];
			for (int i = 0; i < entries.Length; i++)
				result[i] = new Color32(entries[i].R, entries[i].G, entries[i].B, entries[i].A);

			return result;
		}
	}
}